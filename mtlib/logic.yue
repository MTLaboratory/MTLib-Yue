import types from require([[mtlib.constants]])
import serialize from require([[mtlib.string]])


NOOP = ()->nil

isType = (value, ofType)-> (type(value) == ofType)

ensureType = (value, ofType)->
    if not isType(value, ofType) then
        error("Value (type #{type value}) is not of type #{ofType}")

isCallable = (value)->
	if (type(value) == types.FUNC) then return (true)
    mt = getmetatable(value)
	if (mt != nil) and (mt != {}) then
		return (mt.__call != nil) and (type(mt.__call) == types.FUNC)
	(false)

deepCopy = (value)->
	if (type(value) != types.TABLE) then return (value)
	if (#value == 0) then return ({})
	(setmetatable({k,v for k,v in pairs value}, getmetatable(value)))
-- export combine = (t1, t2)->
-- 	if ((t1 == nil) or (t2 == nil)) then return ((t1 or t2) or nil)
-- 	if ((type(t1) == types.TABLE) and (type(t1) == type(t2))) then
-- 		r = _deepCopy(t1)
-- 		for k,v in pairs(t2) do r[k] = v
-- 		return r
-- 	else return (t1 + t2)

isInstanceOf = (value, of)->
    if (value == of) then return (true)
    --if not isType(value, types.TABLE) then return (false)
    --if not isType(of, types.TABLE) then return (false)
    if (value.__class != nil) then
        val_cls = value.__class
        if (of.__class != nil) then
            of_cls = of.__class
            return (val_cls.__name == of_cls.__name)
        return (val_cls.__name == of)
    (false)

isAncestor =(value, of)-> -- REFINE THIS
	if (value == nil or of == nil) then return (false)
	if (value.__parent) then
		if isType(of, types.STRING) then return (value.__parent.__name == of)
		if (of.__class) then
			if (value.__parent == of.__class) then return (true)
			if (value.__parent.__name == of.__class.__name) then return (true)
			else return (isAncestor(value.__parent, of))
	(false)

are =(tbl, of)->
	for _,v in pairs(tbl) do
        if ((type(v) == of) == false) then return (false)
	(true)

areAncestors =(tableOfValues, ofClass)->
	for _,v in pairs(tableOfValues) do
        if (isAncestor(v, ofClass) == false) then return (false)
	(true)

newArray =(count, fillWith)-> ([(fillWith or 0) for i=1, count])

class MTObj
    @Heap: {}
    new:=>
        @__id = #(@@Heap)+1
        @@Heap[@__id] = @
        (@)
    __tostring:=> ("MTObj##{@__id}")

class List extends MTObj
    new: (ofItems)=>
        @Items = {k,v for k,v in pairs(ofItems)}
        (@)
    clear: ()=> @Items = {}
    combine: (withTbl)=>
        if isType(withTbl, types.TABLE) then
            for k,v in pairs(withTbl) do @add(v, k)
        (@)
    __tostring:=> ("List: #{serialize(@Items, ', ')}")
    __len:=> #@Items
    __add: (v1, v2)-> -- TEST ME
        if not isType(v1, types.TABLE) then return (v2\add(v1))
        elseif not isType(v2, types.TABLE) then return (v1\add(v2))
        if isInstanceOf(v1, List) then
            if isInstanceOf(v2, List) then
                for k,v in pairs(v2.Items) do v1\add(v, k)
                return (v1)
            else
                v2L = List(v2)
                return (v1 + v2L)
        elseif isInstanceOf(v2, List) then
            v1L = List(v1)
            return (v1L + v2)
        (nil)
    __index: (k)=> (@Items[k] or nil)
    contains: (value, atKey)=>
        if (atKey != nil) then
            v = @Items[atKey]
            if (v != nil) then
                return (value == v)
        else for _,v in pairs(@Items) do
            if (v == value) then return (true)
        (false)
    removeAt: (idx)=>
        @Items[idx] = nil
        (@Items[idx] == nil)
    remove: (item)=>
        for k,v in pairs(@Items) do
            if (v == item) then
                @Items[k] = nil
                return (true)
        (false)
    forEach: (doFunc, iterations=1)=>
        for k,v in pairs(@Items) do
            for i=1, iterations do
                @Items[k] = (doFunc(v, i, k) or v)
        (@)
    add: (v, k)=>
        k = (k or (#@Items+1))
        @Items[k] = deepCopy(v)
        @Top = @Items[k]
        (@)
    topKey:=> -- does this work??
        lK = nil
        for k,_ in pairs(@Items) do lK = k
        (lK)
    top:=>
        if (@Top != nil) then return (@Top)
        (@Items[@topKey!] or nil)
    pop: (atKey)=>
        table.remove(@Items, (atKey or #@Items))
        (@)
    --push: (v)=>
    --    @Items[@topKey!+1] = v

class Timer extends MTObj
    __tostring:=> ("Timer")
    update: (dT)=>
        now = os.clock!
        love or= nil
        if (love != nil) then
            dT = (dT or love.timer.getDelta!)
        else
            dT = (dT or (now-(@lastUpdate or now)))
        @timeRemaining -= dT
        @lastUpdate = now
        if (@timeRemaining <= 0) then
            if (@oneShot == true and not @hasShot) then
                @onComplete!
                @hasShot = true
                return (true)
            if (@looping == true) then @restart!
            @onComplete!
            return (true)
        (false)
    isComplete:=>
        return ((@timeRemaining <= 0) and (@looping == false))
    restart:=>
        @timeRemaining = @duration
        (@)
    new: (duration, onComplete, oneShot=true, looping=false)=>
        duration or= 1.0
        super!
        @duration = duration
        @oneShot = oneShot
        @hasShot = false
        @onComplete = (onComplete or NOOP)
        @looping = looping
        @lastUpdate = os.clock!
        @restart!
        (@)

{
    :isCallable
    :deepCopy
    :isInstanceOf
    :are
    :areAncestors
    :newArray
    :Timer
    :MTObj
}