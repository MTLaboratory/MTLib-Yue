if not RootPath then error("RootPath not set!")
import types from require("#{RootPath}constants")
-- strings = require("#{RootPath}strings")

NOOP = ()->nil

isType = (value, ofType)-> (type(value) == ofType)

ensureType = (value, ofType)->
    if not isType(value, ofType) then
        error("Value (type #{type value}) is not of type #{ofType}")

isCallable = (value)->
	if isType(value, types.FUNC) then return (true)
    mt = getmetatable(value)
	if (mt != nil) and (mt != {}) and (mt.__call != nil) then
		return isType(mt.__call, types.FUNC)
	(false)

deepCopy = (value)->
    if (type(value) != types.TABLE) then return (value)
	(setmetatable({k,v for k,v in pairs value}, getmetatable(value)))

isInstanceOf = (value, of)->
    if (value == nil) then return (of == nil)
    if (value == of) then return (true)
    if type(value) != "table" then
        return (type(value) == type(of))
    if (value.__class != nil) then
        val_cls = value.__class
        if (of.__class != nil) then
            of_cls = of.__class
            return (val_cls.__name == of_cls.__name)
        return (val_cls.__name == of)
    return (type(of) == types.TABLE)

isAncestor =(value, of)-> -- REFINE THIS
	if (value == nil or of == nil) then return (false)
	if (value.__parent) then
		if isType(of, types.STRING) then return (value.__parent.__name == of)
		if (of.__class) then
			if (value.__parent == of.__class) then return (true)
			if (value.__parent.__name == of.__class.__name) then return (true)
			else return (isAncestor(value.__parent, of))
	(false)

are =(tbl, of)->
	for _,v in pairs(tbl) do
        if (not isType(v, of)) then return (false)
	(true)

areAncestors =(tableOfValues, ofClass)->
	for _,v in pairs(tableOfValues) do
        if (isAncestor(v, ofClass) == false) then return (false)
	(true)

newArray =(count, fillWith)-> ([(fillWith or 0) for i=1, count])

generateUUID =()->
    math.randomseed(os.time!)
	fn =(x)->
		r = (math.random(16)-1)
		r = ((x == "x") and (r+1) or (r%4)+9)
		return ("0123456789abcdef"\sub(r, r))
	("xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"\gsub("[xy]", fn))

class MTObj
    new: =>
        @__id = generateUUID!
        (@)
    -- __tostring:=> ("MTObj: #{@__id}")

class List
    __tostring:=> ("List")
    new: (ofItems)=>
        -- super!
        if (ofItems == nil) then
            @items = {}
            return (@)
        elseif type(ofItems) == types.TABLE then
            @items = {k,v for k,v in pairs(ofItems)}
        else
            @items = {ofItems}
        (@)
    clear: ()=>
        @items = {}
        (@)
    count: ()=> (#@items)
    top: ()=> (@items[#@items] or nil)
    contains: (value)=>
        for _,v in pairs(@items) do
            if (v == value) then return (true)
        (false)
    remove: (item)=>
        for k,v in pairs(@items) do
            if (v == item) then
                @items[k] = nil
                return (true)
        (false)
    forEach: (doFunc, iterations=1)=>
        for k,v in pairs(@items) do
            for i=1, iterations do
                @items[k] = (doFunc(v, i, k) or v)
        (@)
    insert: (v)=>
        @items[(#@items+1)] = deepCopy(v)
        (@)

class Timer extends MTObj
    __tostring:=> ("Timer")
    new: (duration=1.0, onComplete, oneShot=true, looping=false)=>
        super!
        @duration = duration
        @oneShot = oneShot
        @hasShot = false
        @onComplete = (onComplete or NOOP)
        @looping = looping
        @lastUpdate = os.clock!
        @restart!
        (@)
    restart:=>
        @timeRemaining = @duration
        (@)
    update: (dT)=>
        now = os.clock!
        love or= nil
        if (love != nil) then
            dT = (dT or love.timer.getDelta!)
        else
            dT = (dT or (now - (@lastUpdate or now)))
        @timeRemaining -= dT
        @lastUpdate = now
        if (@timeRemaining <= 0) then
            if (@oneShot and not(@hasShot)) then
                @onComplete!
                @hasShot = true
                return (true)
            if @looping then @restart!
            @onComplete!
            return (true)
        (false)
    isComplete:=> ((@timeRemaining <= 0) and not(@looping))
    
{
    :NOOP
    :isCallable
    :isType
    :deepCopy
    :isInstanceOf
    :ensureType
    :isAncestor
    :are
    :areAncestors
    :newArray

    :Timer
    :List
    :MTObj
}