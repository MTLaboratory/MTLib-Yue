if not RootPath then error("RootPath not set!")
import MTObj, isInstanceOf from require("#{RootPath}logic")
import types from require("#{RootPath}constants")

clamp =(v, l=0, u=1)-> math.max(l, math.min(v, u))

sign =(v)->
	(v < 0 and -1 or 1)

sigmoid =(v)->
	(1/(1+math.exp(-v)))

distance =(x, y, x2, y2)->
	math.abs(math.sqrt(math.pow(x2-x, 2)+math.pow(y2-y, 2)))

angleBetween =(x, y, x2, y2)->
	math.abs(math.atan2(y2-y,x2-x))

invLerp =(a, b, d)->
	((d-a)/(b-a))

cerp =(a, b, d)->
	pi = (math.pi or 3.1415)
	f = (1-math.cos(d*pi)*0.5)
	(a*(1-f)+(b*f))

lerp =(a, b, d)->
	(a+(b-a)*clamp(d))

smooth =(a, b, d)->
	t = clamp(d)
	m = t*t*(3-2*t)
	(a+(b-a)*m)

pingPong =(x)->
	(1-math.abs(1-x%2))

isWithinRegion =(x, y, oX, oY, lX, lY)->
	((x > oX and y < lX) and (y > oY and y < lY))

isWithinCircle =(x, y, oX, oY, oR)->
	(distance(x, y, oX, oY) < oR)
-- _intersects =(o1x, o1y, e1x, e1y, o2x, o2y, e2x, e2y)-> TODO
-- 	-- adapted from https://gist.github.com/Joncom/e8e8d18ebe7fe55c3894
-- 	s1x, s1y = (e1x-o1x), (e1y-o1y)
-- 	s2x, s2y = (e2x-o2x), (e2y-o2y)
-- 	s = (-s1y*(o1x-o2x)+s1x*(o1y-o2y))/(-s2x*s1y+s1x*s2y)
-- 	t =  (s2x*(o1y-o2y)-s2y*(o1x-o2x))/(-s2x*s1y+s1x*s2y)
-- 	((s >= 0) and (s <= 1) and (t >= 0) and (t <= 1))

class Dyad extends MTObj
	lerp: (o, d, d1)=>
		if isInstanceOf(o, "Dyad") then
			@position.x = lerp(@position.x, o.position.x, tonumber(d))
			@position.y = lerp(@position.y, o.position.y, tonumber(d))
		elseif isType(o, types.NUMBER) then
			@position.x = lerp(@position.x, o, d1)
			@position.x = lerp(@position.y, d, d1)
		(@)
	get:=> (@position.x), (@position.y)
	equals: (o, o2)=>
		if (o == nil) then
			return (false)
		elseif (not isType(o, types.TABLE) and (o2 == nil)) then
			return (false)
		elseif isInstanceOf(o, "Dyad") then
			return (
				(@position.x == o.position.x) and
				(@position.y == o.position.y)
			)
		elseif (isType(o2, types.NUMBER) and (o != nil)) then
			return ((@position.x == o) and (@position.y == o2))
		(false)
	distance: (o=0, o2=0)=>
		if (isType(o, types.NUMBER) and isType(o2, types.NUMBER)) then
			return distance(@position.x, @position.y, o, o2)
		if isInstanceOf(o, "Dyad") then
			return @distance(o.position.x, o.position.y)
		(nil)
	set: (x, y)=>
		@position or= {}
		@position.x, @position.y = tonumber(x or 0), tonumber(y or 0)
		(@)
	__call: (x, y)=> @set(x, y)
	new: (x, y)=>
		super!
		@(x, y)

class Tetrad extends Dyad
	lerp: (o, d)=>
		if isInstanceOf(o, "Tetrad") then
			super\lerp(o, d)
			@velocity.x = lerp(@velocity.x, o.position.x, tonumber(d))
			@velocity.y = lerp(@velocity.y, o.position.y, tonumber(d))
		(@)
	distance: (o)=> (super\distance(o))
	set: (x, y, xV, yV)=>
		super\set(x, y)
		@velocity or= {}
		@velocity.x, @velocity.y = tonumber(xV or 0), tonumber(yV or 0)
	get:=> unpack({
		@position.x, @position.y,
		@velocity.x, @velocity.y })
	update: (dT=(1/60))=>
		@position.x += (@velocity.x*dT)
		@position.y += (@velocity.y*dT)
	impulse: (angle, force)=>
		v = (math.cos(angle)*force)
		@velocity.x += v
		@velocity.y += v
	__call: (x, y, xV, yV)=>
		@set(x, y, xV, yV)
		(@)
	new: (x, y, xV, yV)=>
		super!
		@(x, y, xV, yV)

class Hexad extends Tetrad
	new: (x, y, xV, yV, r, rV)=>
		super!
		(@set(x, y, xV, yV, r, rV))
	__tostring:=> ("Hexad")
	set: (x, y, xV, yV, r, rV)=>
		super\set(x, y, xV, yV)
		@rotator or= {}
		@rotator.value = tonumber(r or 0)
		@rotator.inertia = tonumber(rV or 0)
		(@)
	get:=> unpack({
		@position.x, @position.y,
		@velocity.x, @velocity.y,
		@rotator.value, @rotator.inertia })
	update: (dT=(1 / 60))=>
		super\update(dT)
		@rotator.value += (@rotator.inertia * dT)
		(@)
	torque: (by)=>
		@rotator.inertia += tonumber(by)
		(@)

class Octad extends Hexad
	new: (x, y, xV, yV, r, rV, dA, dE)=>
		super!
		(@set(x, y, xV, yV, r, rV, dA, dE))
	set: (x, y, xV, yV, r, rV, dA, dE)=>
		super\set(x, y, xV, yV, r, rV)
		@dimensional or= {}
		@dimensional.address = tonumber(dA or 0)
		@dimensional.entropy = tonumber(dE or 0)
		(@)
	get:=> unpack({
		@position.x, @position.y,
		@velocity.x, @velocity.y,
		@rotator.value, @rotator.inertia,
		@dimensional.address, @dimensional.entropy })
	shake: (by)=>
		@dimensional.entropy += tonumber(by)
	update: (dT=(1 / 60))=>
		super\update(dT)
		@dimensional.address += (@dimensional.entropy * dT)
		(@)

class Shape extends MTObj
	new: ()=>
		super!
		@origin = Dyad(0, 0)
		(@)
	setOrigin: (oX, oY)=>
		@origin.position.x = tonumber(oX or error("oX required!"))
		@origin.position.y = tonumber(oY or error("oY required!"))
		(@)

class Circle extends Shape
	new: (x, y, rad)=>
		super!
		(@set(x, y, rad))
	set: (oX, oY, radi)=>
		super\setOrigin(oX, oY)
		@radius = tonumber(radi or math.pi)
		(@)
	draw: (mode)=>
		love = love or error("Missing LOVE2D!")
		love.graphics.circle(mode, @origin.x, @origin.y, @radius)
		(@)

class Line extends Shape
	new: (oX, oY, eX, eY)=>
		super!
		(@set(oX, oY, eX, eY))
	set: (oX, oY, eX, eY)=>
		super\set(oX, oY)
		@ending = Dyad(eX, eY)
		(@)
	get:=> unpack({
		@origin.position.x, @origin.position.y,
		@ending.position.x, @ending.position.y })
	--distance: (o, o2)=> error!
	getLength:=>
		sOX, sOY = @origin\get!
		sEX, sEY = @ending\get!
		(math.sqrt(math.pow(sEX-sOX, 2) + math.pow(sEY - sOY, 2)))
	getSlope:=>
		(
			(@ending.position.x - @origin.position.x) /
			(@ending.position.y - @origin.position.y)
		)
	intersects: (o)=> error!
		-- if isInstanceOf(o, 'Dyad') then
		-- 	sOX, sOY, sEX, sEY = @get!
		-- 	oPX, oPY = o\get!
		-- 	slope = @getSlope!
		-- 	return ((slope*sOX+oPX == 0) or (slope*sEX+sPY == 0))
		-- elseif isInstanceOf(o, 'Line') then
		-- 	sOX, sOY, sEX, sEY = @get!
		-- 	oOX, oOY, oEX, oEY = o\get!
		-- 	if (_intersects(sOX, sOY, sEX, sEY, oOX, oOY, oEX, oEY)) then return (true)
		-- elseif isInstanceOf(o, 'Rectangle') then
		-- 	if (o\contains(@Origin) or o\contains(@Ending)) then return (true)
		-- 	for i,l in ipairs(o\getLines!) do if (@intersects(l)) then return (true)

class Rectangle extends Shape
	new: (oX, oY, lX, lY)=>
		super!
		(@set(oX, oY, lX, lY))
	set: (oX, oY, lX, lY)=>
		super\setOrigin(oX, oY)
		@limits or= Dyad(lX, lY)
		(@)
	get:=> unpack({
		@origin.position.x, @origin.position.y,
		@limits.position.x, @limits.position.y })
	area:=> (@limits.position.x*@limits.position.y)
	perimeter:=>
		((2 * (@limits.position.x)) + (2 * (@limits.position.y)))
	diagonal:=>
		math.sqrt(((@limits.position.x) ^ 2)+((@limits.position.y) ^ 2))
	contains: (o)=>
		if isInstanceOf(o, "Dyad") then
			sOX, sOY, sLX, sLY = @get!
			oPX, oPY = o\get!
			return isWithinRegion(oPX, oPY, sOX, sOY, sLX, sLY)
		elseif isInstanceOf(o, "Line") then
			return (@contains(o.origin) and @contains(o.ending))
		elseif isInstanceOf(o, "Rectangle") then
			for i,l in ipairs(o\getLines!) do
				if (@contains(l) == false) then return (false)
			return (true)
		(nil)
	render:=>
		sOX, sOY, sLX, sLY = @get!
		({ sOX, sOY, sOX, sLY,
			sOX, sLY, sLX, sLY,
			sLX, sLY, sLX, sOY,
			sLX, sOY, sOX, sOY })
	getLines:=>
		sOX, sOY, sLX, sLY = @get!
		({ Line(sOX, sOY, sOX, sLY),
			Line(sOX, sLY, sLX, sLY),
			Line(sLX, sLY, sLX, sOY),
			Line(sLX, sOY, sOX, sOY) })

class Polygon extends Shape
    new:=>
		super!
		error!

class Color
	new: (r=1, g=1, b=1, a=1)=>
		@R = clamp(tonumber(r or 1), 0, 1)
		@G = clamp(tonumber(g or 1), 0, 1)
		@B = clamp(tonumber(b or 1), 0, 1)
		@A = clamp(tonumber(a or 1), 0, 1)
		(@)
	__add: (othercolor)=>
		if not isInstanceOf(othercolor, Color) then return (nil)
		Color(
			clamp(@R + othercolor.R, 0, 1),
			clamp(@G + othercolor.G, 0, 1),
			clamp(@B + othercolor.B, 0, 1),
			clamp(@A + othercolor.A, 0, 1)
		)
	__sub: (value)=>
		if not isInstanceOf(value, Color) then return (nil) -- this needs testing
		Color(
			clamp(@R - value.R, 0, 1),
			clamp(@G - value.G, 0, 1),
			clamp(@B - value.B, 0, 1),
			clamp(@A - value.A, 0, 1)
		)
	__div: (value)=>
		if not isInstanceOf(value, Color) then return (nil)
		Color(
			clamp(@R / value.R, 0, 1),
			clamp(@G / value.G, 0, 1),
			clamp(@B / value.B, 0, 1),
			clamp(@A / value.A, 0, 1)
		)
	__mul: (value)=>
		if not isInstanceOf(value, Color) then return (nil)
		Color(
			clamp(@R * value.R, 0, 1),
			clamp(@G * value.G, 0, 1),
			clamp(@B * value.B, 0, 1),
			clamp(@A * value.A, 0, 1)
		)
	__eq: (value)=>
		if not isInstanceOf(value, Color) then return (false)
		((@R == value.R) and (@G == value.G) and (@B == value.B) and (@A == value.A))
	__call: ()=>
		({@R, @G, @B, @A})
	__tostring:=> ("Color(#{@R}, #{@G}, #{@B}, #{@A})")

{
    :sign
    :sigmoid
    :angleBetween
    :lerp
    :inverseLerp
    :cosineLerp
    :smooth
    :pingPong
    :isWithinRegion
    :isWithinCircle

	:Color

    :Dyad
    :Tetrad
    :Hexad
    :Octad

    :Shape
    :Line
    :Circle
    :Rectangle
    :Polygon
}